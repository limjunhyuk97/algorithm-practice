# Knapsack

- zero-one knapsack : Dynamic programming
- non zero-one knapsack : Greedy Algorithm

## [참고](https://github.com/limjunhyuk97/BOJ/blob/main/Gold/12865_DP_0-1Knapsack/README.md)

## 결국 구해야할 것이 무엇인가? / 이전 단계의 연산결과가 새 연산에 적용이 되는가?

### BOJ_12865. 평범한 배낭

- 전체 무게가 ~ 일때 -> **결국 구해야하는 것 : 최대로 담을 수 있는 보석의 가치**
- 보석 무게x , 전체 무게y -> **보석 가치 (가중치를 더하는 것)**
- 이전 단계의 수치를 이용 (max 가치)

### BOJ_9084. 동전

- 전체 금액이 ~ 일때 -> **결국 구해야하는 것 : 동전 조합의 수**
- 동전 액수x, 전체 금액y -> **조합의 수 (단순 수를 더하는 것)**
- 이전 단계의 수치를 이용 (+= 조합의 수)

### BOJ_10023. MooMoo

- 전체 소의 울음소리가 ~일 때 -> **결국 구해야 하는 것 : 소 조합의 수**
- 울음 크기x, 전체 울음y -> **조합의 수 (단순 수를 더하는 것)**
- 이전 단계의 수치를 이용 (min 조합의 수) 

### BOJ_1082. 방 번호

- 전체 금액이 ~일 때 -> **결국 구해야 하는 것 : 조합하여 만들 수 있는 최대 수**
- 번호판 금액x, 전체 예산y -> **번호판 조합의 수 (문자열을 조합)**
- 이전 단계의 수치를 이용 (max 번호판)

### BOJ_1106. 호텔

- 목표 : 최소한의 비용을 계산 하는 것 / 제약 : 사람 수가 n명 이상 모집되어야 함
- DP[n] = min(DP[n-w[i]]+v[i], DP[n])